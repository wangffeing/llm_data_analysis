import asyncio
import json
import logging
import uuid
from datetime import datetime
from collections import defaultdict
from typing import Dict, Any, List, AsyncGenerator, Optional, Set
from enum import Enum
from weakref import WeakSet

logger = logging.getLogger(__name__)

class SSEMessageType(Enum):
    """SSE消息类型"""
    ROUND_START = "round_start"
    ROUND_END = "round_end"
    POST_START = "post_start"
    POST_END = "post_end"
    POST_ERROR = "post_error"
    POST_MESSAGE_UPDATE = "post_message_update"
    POST_ATTACHMENT_UPDATE = "post_attachment_update"
    POST_STATE_UPDATE = "post_status_update"
    POST_SEND_TO_UPDATE = "post_send_to_update"
    FILE_GENERATED = "file_generated"
    HEARTBEAT = "heartbeat"
    ERROR = "error"
    SESSION_CREATED = "session_created"
    CHAT_COMPLETED = "chat_completed"
    SHUTDOWN = "shutdown"  # 新增，用于服务关闭通知

class SSEJSONEncoder(json.JSONEncoder):
    """自定义JSON编码器，处理枚举和其他特殊类型"""
    def default(self, obj):
        if isinstance(obj, Enum):
            return obj.value
        elif isinstance(obj, datetime):
            return obj.isoformat()
        return super().default(obj)

class SSEMessage:
    """SSE消息数据结构"""
    def __init__(self, message_type: SSEMessageType, data: Dict[str, Any], session_id: str):
        self.id = f"msg_{int(datetime.now().timestamp() * 1000000)}_{uuid.uuid4().hex[:8]}"
        self.type = message_type
        self.data = data
        self.session_id = session_id
        self.timestamp = datetime.now().isoformat()
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "type": self.type.value,
            "data": self.data,
            "session_id": self.session_id,
            "timestamp": self.timestamp
        }
    
    def format_for_sse(self) -> str:
        """格式化为SSE标准数据格式"""
        try:
            safe_data = {
                "session_id": self.session_id,
                "timestamp": self.timestamp,
                **self.data
            }
            data_str = json.dumps(safe_data, ensure_ascii=False, cls=SSEJSONEncoder)
            lines = [f"id: {self.id}", f"event: {self.type.value}"]
            lines.extend([f"data: {line}" for line in data_str.split('\n')])
            lines.append("")
            return "\n".join(lines) + "\n"
        except Exception as e:
            logger.error(f"SSE格式化失败: {e}")
            return f"id: error_{int(datetime.now().timestamp())}\nevent: error\ndata: {{\"error\": \"格式化失败\"}}\n\n"

class ConnectionManager:
    """连接管理器，负责管理单个会话的所有连接"""
    
    def __init__(self, session_id: str):
        self.session_id = session_id
        self.connections: List[asyncio.Queue] = []
        self.lock = asyncio.Lock()
        self.created_at = datetime.now()
        self.last_activity = datetime.now()
    
    async def add_connection(self, queue: asyncio.Queue):
        """添加连接"""
        async with self.lock:
            self.connections.append(queue)
            self.last_activity = datetime.now()
            logger.info(f"会话 {self.session_id} 添加连接，当前连接数: {len(self.connections)}")
    
    async def remove_connection(self, queue: asyncio.Queue):
        """移除连接"""
        async with self.lock:
            if queue in self.connections:
                self.connections.remove(queue)
                self.last_activity = datetime.now()
                logger.info(f"会话 {self.session_id} 移除连接，当前连接数: {len(self.connections)}")
    
    async def broadcast_message(self, formatted_data: str):
        """向所有连接广播消息"""
        async with self.lock:
            if not self.connections:
                return
            
            dead_queues = []
            for queue in self.connections:
                try:
                    queue.put_nowait(formatted_data)
                except asyncio.QueueFull:
                    logger.warning(f"会话 {self.session_id} 队列满，丢弃消息")
                except Exception as e:
                    logger.error(f"会话 {self.session_id} 发送失败: {e}")
                    dead_queues.append(queue)
            
            # 清理失效队列
            for queue in dead_queues:
                if queue in self.connections:
                    self.connections.remove(queue)
            
            self.last_activity = datetime.now()
    
    def is_empty(self) -> bool:
        """检查是否没有活跃连接"""
        return len(self.connections) == 0
    
    def get_connection_count(self) -> int:
        """获取连接数"""
        return len(self.connections)

class SSEService:
    """改进的SSE服务：支持多会话、多连接、心跳、同步调用、安全关闭"""

    def __init__(self):
        self._session_managers: Dict[str, ConnectionManager] = {}
        self._running: bool = True
        self._global_lock = asyncio.Lock()
        self.loop: Optional[asyncio.AbstractEventLoop] = None
        self._heartbeat_task: Optional[asyncio.Task] = None
        self._cleanup_task: Optional[asyncio.Task] = None
        
        # 统计信息
        self._total_messages_sent = 0
        self._total_connections_created = 0
        self._start_time = datetime.now()

    def configure(self, loop: asyncio.AbstractEventLoop):
        """配置事件循环并启动后台任务"""
        self.loop = loop
        
        # 启动心跳任务
        self._heartbeat_task = loop.create_task(self._heartbeat_worker())
        
        # 启动清理任务
        self._cleanup_task = loop.create_task(self._cleanup_worker())
        
        logger.info("SSE服务已配置并启动后台任务")

    async def add_connection(self, session_id: str) -> AsyncGenerator[str, None]:
        """注册新连接，开始推送数据流"""
        queue = asyncio.Queue(maxsize=500)
        connection_id = uuid.uuid4().hex[:8]
        
        # 获取或创建会话管理器
        async with self._global_lock:
            if session_id not in self._session_managers:
                self._session_managers[session_id] = ConnectionManager(session_id)
            session_manager = self._session_managers[session_id]
        
        await session_manager.add_connection(queue)
        self._total_connections_created += 1
        
        logger.info(f"添加SSE连接 session={session_id} conn={connection_id}")

        # 发送连接确认消息
        await self.send_message(session_id, SSEMessageType.HEARTBEAT, {
            "message": "连接已建立",
            "connection_id": connection_id,
            "timestamp": datetime.now().isoformat()
        })

        try:
            while self._running:
                try:
                    data = await asyncio.wait_for(queue.get(), timeout=30.0)
                    yield data
                except asyncio.TimeoutError:
                    # 发送心跳
                    heartbeat = SSEMessage(
                        session_id=session_id,
                        message_type=SSEMessageType.HEARTBEAT,
                        data={"message": "heartbeat", "timestamp": datetime.now().isoformat()}
                    )
                    yield heartbeat.format_for_sse()
                except asyncio.CancelledError:
                    logger.info(f"客户端取消连接 session={session_id} conn={connection_id}")
                    break
        except Exception as e:
            logger.error(f"SSE连接错误 session={session_id} conn={connection_id}: {e}")
            await self.send_message(session_id, SSEMessageType.ERROR, {"message": "连接错误"})
        finally:
            await session_manager.remove_connection(queue)
            
            # 如果会话没有连接了，清理会话管理器
            async with self._global_lock:
                if session_manager.is_empty():
                    if session_id in self._session_managers:
                        del self._session_managers[session_id]
                        logger.info(f"清理空会话管理器: {session_id}")

    async def send_message(self, session_id: str, message_type: SSEMessageType, data: Dict[str, Any]):
        """异步发送消息给指定会话的所有连接"""
        if not self._running:
            logger.warning("SSE服务未运行，跳过发送")
            return

        message = SSEMessage(message_type, data, session_id)
        formatted_data = message.format_for_sse()

        async with self._global_lock:
            if session_id not in self._session_managers:
                logger.debug(f"会话 {session_id} 不存在，跳过发送")
                return
            session_manager = self._session_managers[session_id]

        await session_manager.broadcast_message(formatted_data)
        self._total_messages_sent += 1
        
        logger.debug(f"发送消息 session={session_id} type={message_type.value}")

    def send_message_from_sync(self, session_id: str, message_type: SSEMessageType, data: Dict[str, Any]):
        """允许从线程中同步安全发送消息"""
        if not self._running or not self.loop:
            logger.warning("无法从同步发送SSE：服务未配置或已关闭")
            return

        try:
            asyncio.run_coroutine_threadsafe(
                self.send_message(session_id, message_type, data),
                self.loop
            )
        except Exception as e:
            logger.error(f"同步发送SSE消息失败: {e}")

    async def _heartbeat_worker(self):
        """心跳工作器，定期发送心跳消息"""
        while self._running:
            try:
                await asyncio.sleep(30)  # 30秒心跳间隔
                
                if not self._running:
                    break
                
                async with self._global_lock:
                    session_ids = list(self._session_managers.keys())
                
                for session_id in session_ids:
                    await self.send_message(session_id, SSEMessageType.HEARTBEAT, {
                        "message": "定期心跳",
                        "timestamp": datetime.now().isoformat()
                    })
                    
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"心跳工作器错误: {e}")

    async def _cleanup_worker(self):
        """清理工作器，定期清理无效会话"""
        while self._running:
            try:
                await asyncio.sleep(300)  # 5分钟清理间隔
                
                if not self._running:
                    break
                
                # 清理空的会话管理器
                async with self._global_lock:
                    empty_sessions = [
                        session_id for session_id, manager in self._session_managers.items()
                        if manager.is_empty()
                    ]
                    
                    for session_id in empty_sessions:
                        del self._session_managers[session_id]
                        logger.info(f"清理空会话: {session_id}")
                        
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"清理工作器错误: {e}")

    async def cleanup(self):
        """关闭所有连接并清理资源"""
        self._running = False
        logger.info("SSE服务关闭中，通知所有连接...")

        # 取消后台任务
        if self._heartbeat_task:
            self._heartbeat_task.cancel()
            try:
                await self._heartbeat_task
            except asyncio.CancelledError:
                pass
        
        if self._cleanup_task:
            self._cleanup_task.cancel()
            try:
                await self._cleanup_task
            except asyncio.CancelledError:
                pass

        # 通知所有连接服务即将关闭
        async with self._global_lock:
            for session_id, session_manager in self._session_managers.items():
                shutdown_msg = SSEMessage(
                    message_type=SSEMessageType.SHUTDOWN,
                    data={"message": "服务即将关闭"},
                    session_id=session_id
                ).format_for_sse()

                await session_manager.broadcast_message(shutdown_msg)

            self._session_managers.clear()

        logger.info("SSE服务清理完成")

    def get_stats(self) -> Dict[str, Any]:
        """获取服务统计信息"""
        total_connections = sum(
            manager.get_connection_count() 
            for manager in self._session_managers.values()
        )
        
        return {
            "running": self._running,
            "total_sessions": len(self._session_managers),
            "total_connections": total_connections,
            "total_messages_sent": self._total_messages_sent,
            "total_connections_created": self._total_connections_created,
            "uptime_seconds": (datetime.now() - self._start_time).total_seconds(),
            "session_details": {
                session_id: {
                    "connection_count": manager.get_connection_count(),
                    "created_at": manager.created_at.isoformat(),
                    "last_activity": manager.last_activity.isoformat()
                }
                for session_id, manager in self._session_managers.items()
            }
        }
