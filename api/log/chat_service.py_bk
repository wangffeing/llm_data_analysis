import re
from datetime import datetime
from typing import Dict, Any, List, Tuple
import os
import base64
import mimetypes

from services.sse_service import SSEService
from event_handlers.sse_event_handler import SSEEventHandler, SSEMessageType
from session_manager import SessionManager
from models.chat_models import ChatMessage
from config import DATA_SOURCES
import logging
from taskweaver.memory.attachment import AttachmentType
import asyncio
from concurrent.futures import ThreadPoolExecutor
import textwrap

logger = logging.getLogger(__name__)  # 需要添加

FILE_TYPE_MAP = {
    ('png', 'jpg', 'jpeg', 'gif', 'bmp', 'svg'): 'image',
    ('mp3', 'wav', 'flac', 'aac'): 'audio',
    ('csv',): 'csv',
    ('xlsx', 'xls'): 'excel',
    ('pdf',): 'pdf',
    ('txt', 'log'): 'text',
    ('py', 'js', 'html', 'css', 'json'): 'code'
}


class ChatService:
    def __init__(self,
                 session_manager: SessionManager,
                 taskweaver_app,
                 sse_service: SSEService):
        self.session_manager = session_manager
        self.taskweaver_app = taskweaver_app
        self.sse_service = sse_service
        self.executor = ThreadPoolExecutor(max_workers=10)

    async def process_message(self, session_id: str, message: ChatMessage):
        """处理聊天消息"""
        try:
            session_data = self.session_manager.get_session(session_id)
            if not session_data:
                await self.sse_service.send_message(session_id, SSEMessageType.ERROR, {
                    "message": "会话不存在"
                })
                return

            user_message = {
                "role": "user",
                "content": message.content,
                "selected_table": message.selected_table,
                "timestamp": datetime.now().isoformat(),
                "is_intermediate": False
            }
            session_data["messages"].append(user_message)

            taskweaver_session = await self._get_or_create_taskweaver_session(
                session_data, session_id
            )

            prompt = await self._build_prompt(message, session_id)

            # 使用新的事件处理器
            event_handler = SSEEventHandler(session_id, self.sse_service)

            try:
                # 在单独的线程中运行阻塞的taskweaver调用
                loop = asyncio.get_running_loop()
                response_round = await loop.run_in_executor(
                    self.executor,  # 使用默认的线程池执行器
                    lambda: taskweaver_session.send_message(
                        prompt,
                        event_handler=event_handler
                    )
                )

                final_response, files = await self._process_taskweaver_response(
                    response_round, session_data
                )

                # 发送完成消息
                data = {"response": final_response}
                if files:
                    data["files"] = files
                await self.sse_service.send_message(session_id, SSEMessageType.CHAT_COMPLETED, data)

            finally:
                event_handler.cleanup()

        except Exception as e:
            logger.exception(f"TaskWeaver执行失败 session={session_id}: {e}")

            await self.sse_service.send_message(session_id, SSEMessageType.ERROR, {"error": str(e)})

    async def _build_prompt(self, message: ChatMessage, session_id: str) -> str:
        """构建提示词"""
        prompt = message.content

        if message.selected_table:
            if message.selected_table not in DATA_SOURCES:
                await self.sse_service.send_message(session_id, SSEMessageType.ERROR, {"error": "选择的数据源不存在"})
                raise Exception("选择的数据源不存在")

            table_info = DATA_SOURCES[message.selected_table]

            prompt = textwrap.dedent(f"""
                请使用sql_pull_data插件从数据库中获取数据并完成任务。
                表名: {table_info['table_name']}
                表描述: {table_info['table_des']}
                字段信息: {table_info['table_columns']}
                字段描述: {table_info['table_columns_names']}
                请先从数据库中获取对应的数据，然后完成任务。

                任务：{message.content}

                请使用中文回复。
            """).strip()

        return prompt

    async def _get_or_create_taskweaver_session(self, session_data: Dict, session_id: str):
        """获取或创建TaskWeaver会话"""
        taskweaver_session = session_data.get("taskweaver_session")
        if taskweaver_session is None:
            taskweaver_session = self.taskweaver_app.get_session()
            session_data["taskweaver_session"] = taskweaver_session
            logger.info(f"Created new TaskWeaver session for {session_id}")
        return taskweaver_session

    async def _process_taskweaver_response(self, response_round, session_data) -> Tuple[str, List[Dict]]:
        """处理TaskWeaver响应"""
        final_response = ""
        session_cwd_path = session_data["taskweaver_session"].execution_cwd
        files = []
        # 提取artifact_paths
        artifact_paths = [
            p for post in response_round.post_list
            for a in post.attachment_list
            if a.type == AttachmentType.artifact_paths
            for p in a.content
        ]

        seen_paths = set()

        for post in response_round.post_list:
            if post.send_from == "User":
                continue

            final_response = post.message

            # 新的文件引用正则：file_name: xxx.ext
            pattern = r"file_name:\s*([\w\-. ]+\.[a-zA-Z0-9]+)"
            matches = re.findall(pattern, post.message)

            for file_name in matches:
                if file_name in seen_paths:
                    continue
                seen_paths.add(file_name)

                file_path = file_name  # 文件名即文件路径（可扩展为映射关系）

                # 构造绝对路径
                absolute_file_path = file_path if os.path.isabs(file_path) else os.path.join(session_cwd_path, file_path)

                # 读取文件内容
                file_content = await self._read_file_content(absolute_file_path)
                if file_content:
                    files.append({
                        "name": file_name,
                        "path": file_path,
                        "type": "file",  # 如果你未来有区分 image，可以再加类型判断
                        "content": file_content,
                        "mime_type": self._get_mime_type(file_path)
                    })

        # if len(files) == 0:
        #     for filename in os.listdir(session_cwd_path):
        #         file_path = os.path.join(session_cwd_path, filename)

        #         if filename in seen_paths:
        #             continue
        #         seen_paths.add(filename)

        #         if not os.path.isfile(file_path):  # 可选增强
        #             continue

        #         # 相对路径
        #         relative_path = os.path.relpath(file_path, session_cwd_path)
        #         file_content = await self._read_file_content(file_path)
        #         if file_content:
        #             files.append({
        #                 "name": filename,
        #                 "path": relative_path,
        #                 "type": "file",
        #                 "content": file_content,
        #                 "mime_type": self._get_mime_type(file_path)
        #             })

        # # 处理用户消息
        # for post in response_round.post_list:
        #     if post.send_from == "User":
        #         continue

        #     final_response = post.message

        #     # 处理文件引用
        #     pattern = r"(!?)\[(.*?)\]\((.*?)\)"
        #     matches = re.findall(pattern, post.message)

        #     for match in matches:
        #         img_prefix, file_name, file_path = match
        #         if "://" not in file_path:  # 本地文件
        #             # 读取文件内容
        #             absolute_file_path = file_path if os.path.isabs(file_path) else os.path.join(session_cwd_path,
        #                                                                                          file_path)
        #             file_content = await self._read_file_content(absolute_file_path)
        #             files.append({
        #                 "name": file_name,
        #                 "path": file_path,
        #                 "type": "image" if img_prefix else "file",
        #                 "content": file_content,
        #                 "mime_type": self._get_mime_type(file_path)
        #             })

        # 添加artifact文件
        for file_path in artifact_paths:
            file_name = os.path.basename(file_path)
            if file_name in seen_paths:
                continue
            seen_paths.add(file_name)
            absolute_file_path = file_path if os.path.isabs(file_path) else os.path.join(session_cwd_path,
                                                                                         file_path)
            file_content = await self._read_file_content(absolute_file_path)
            files.append({
                "name": file_name,
                "path": file_path,
                "type": self._get_file_type(file_path),
                "content": file_content,
                "mime_type": self._get_mime_type(file_path)
            })

        return final_response, files

    async def _read_file_content(self, file_path: str) -> str:
        """读取文件内容并转换为base64编码"""
        try:
            if not os.path.exists(file_path):
                logger.warning(f"文件不存在: {file_path}")
                return ""

            # 检查文件大小（限制为10MB）
            file_size = os.path.getsize(file_path)
            if file_size > 10 * 1024 * 1024:  # 10MB
                logger.warning(f"文件过大，跳过读取: {file_path} ({file_size} bytes)")
                return ""

            # 读取文件内容
            with open(file_path, 'rb') as f:
                file_bytes = f.read()

            # 转换为base64编码
            base64_content = base64.b64encode(file_bytes).decode('utf-8')
            logger.info(f"成功读取文件: {file_path} ({file_size} bytes)")
            return base64_content

        except Exception as e:
            logger.error(f"读取文件失败: {file_path}, 错误: {e}")
            return ""

    def _get_mime_type(self, file_path: str) -> str:
        """获取文件的MIME类型"""
        mime_type, _ = mimetypes.guess_type(file_path)
        if mime_type and mime_type.startswith('image'):
            mime_type = 'image'
        if file_path.endswith('plotly.json') or file_path.endswith('plot.json'):
            mime_type = 'plotly'
        return mime_type or "application/octet-stream"

    def _get_file_type(self, file_path: str) -> str:
        ext = os.path.splitext(file_path)[1][1:].lower()
        for exts, file_type in FILE_TYPE_MAP.items():
            if ext in exts:
                return file_type
        return 'file'

    def shutdown(self):
        self.executor.shutdown(wait=False)
