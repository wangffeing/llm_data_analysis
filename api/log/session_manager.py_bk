import logging
import uuid
import threading
import shutil
import os
from typing import Dict, Optional, List
from datetime import datetime, timedelta
from taskweaver.session.session import Session
from taskweaver.app.app import TaskWeaverApp
import copy

logger = logging.getLogger(__name__)

class SessionManager:
    """改进的TaskWeaver会话管理器，支持会话级别配置"""

    def __init__(self, cleanup_interval_minutes: int = 20):
        self.sessions: Dict[str, Dict] = {}
        self.conversation_ids: Dict[str, str] = {}
        self.cleanup_interval_minutes = cleanup_interval_minutes
        self._lock = threading.RLock()
        self._cleanup_timer: Optional[threading.Timer] = None
        self._start_cleanup_timer()
        
        # 默认配置模板
        self.default_config = {
            "llm.api_type": "qwen",
            "llm.model": "qwen3-32b",
            "execution_service.kernel_mode": "local",
            "code_generator.enable_auto_plugin_selection": "false",
            "code_interpreter.code_verification_on": "false",
            "code_interpreter.allowed_modules": ["pandas", "matplotlib", "numpy", "sklearn", "scipy", "seaborn", "datetime", "typing", "json"],
            "logging.log_file": "taskweaver.log",
            "logging.log_folder": "logs",
            "logging.log_level": "WARNING",
            "planner.prompt_compression": "false",
            "code_generator.prompt_compression": "false",
            "session.max_internal_chat_round_num": 20,
            "session.roles": ["planner", "code_interpreter", "recepta"]
        }
        
    def _start_cleanup_timer(self):
        """启动定时清理任务"""
        if self._cleanup_timer:
            self._cleanup_timer.cancel()
        
        self._cleanup_timer = threading.Timer(
            self.cleanup_interval_minutes * 60,
            self._periodic_cleanup
        )
        self._cleanup_timer.daemon = True
        self._cleanup_timer.start()
        
    def _periodic_cleanup(self):
        """定期清理非活跃会话"""
        try:
            self.cleanup_inactive_sessions(self.cleanup_interval_minutes)
        except Exception as e:
            logger.error(f"定期清理会话失败: {e}")
        finally:
            self._start_cleanup_timer()
        
    def create_session(self, session_id: str = None, custom_config: Dict = None) -> str:
        """创建新会话，支持自定义配置"""
        if session_id is None:
            session_id = str(uuid.uuid4())
            
        with self._lock:
            if session_id in self.sessions:
                logger.warning(f"Session {session_id} already exists")
                return session_id
    
            try:
                conversation_id = str(uuid.uuid4())
                created_at = datetime.now()
                
                # 合并默认配置和自定义配置
                session_config = copy.deepcopy(self.default_config)
                if custom_config:
                    session_config.update(custom_config)
    
                self.sessions[session_id] = {
                    "conversation_id": conversation_id,
                    "taskweaver_session": None,
                    "taskweaver_app": None,  # 会话专用的TaskWeaver应用实例
                    "messages": [],
                    "created_at": created_at.isoformat(),
                    "last_activity": created_at,
                    "status": "active",
                    "user_agent": None,
                    "last_heartbeat": created_at,
                    "workspace_path": None,
                    "session_config": session_config  # 会话级别配置
                }
                
                self.conversation_ids[session_id] = conversation_id
                logger.info(f"Created session: {session_id} with conversation: {conversation_id}")
                return session_id
                
            except Exception as e:
                logger.error(f"Failed to create session {session_id}: {e}")
                raise

    def update_session_config(self, session_id: str, new_config: Dict) -> bool:
        """更新会话配置并重建TaskWeaver会话"""
        with self._lock:
            if session_id not in self.sessions:
                return False
            
            session_data = self.sessions[session_id]
            
            # 更新配置
            session_data["session_config"].update(new_config)
            
            # 清理现有的TaskWeaver会话，强制重建
            if "taskweaver_session" in session_data:
                try:
                    taskweaver_session = session_data["taskweaver_session"]
                    if taskweaver_session and hasattr(taskweaver_session, 'stop'):
                        taskweaver_session.stop()
                except Exception as e:
                    logger.error(f"停止TaskWeaver会话失败: {e}")
                
                session_data["taskweaver_session"] = None
                session_data["taskweaver_app"] = None
            
            logger.info(f"会话 {session_id} 配置已更新，将在下次使用时重建TaskWeaver会话")
            return True
    
    def get_session_config(self, session_id: str) -> Optional[Dict]:
        """获取会话的配置"""
        with self._lock:
            if session_id not in self.sessions:
                return None
            return self.sessions[session_id].get("session_config", {})
    
    def create_taskweaver_app_for_session(self, session_id: str, base_taskweaver_app) -> Optional[object]:
        """为会话创建专用的TaskWeaver应用实例"""
        with self._lock:
            if session_id not in self.sessions:
                return None
            
            session_data = self.sessions[session_id]
            session_config = session_data.get("session_config", {})
            
            try:
                # 创建会话专用的TaskWeaver应用
                # 这里需要根据TaskWeaver的API来实现
                # 暂时返回基础应用，实际实现需要根据TaskWeaver的配置机制
                session_data["taskweaver_app"] = base_taskweaver_app
                return base_taskweaver_app
                
            except Exception as e:
                logger.error(f"Failed to create TaskWeaver app for session {session_id}: {e}")
                return None

    def get_session(self, session_id: str) -> Optional[Dict]:
        """获取指定的会话"""
        with self._lock:
            if session_id not in self.sessions:
                return None
            
            # 更新最后活动时间
            self.sessions[session_id]["last_activity"] = datetime.now()
            return self.sessions[session_id]

    def get_or_create_session(self, session_id: str, custom_config: Dict = None) -> Dict:
        with self._lock:
            session = self.sessions.get(session_id)
            if session:
                session["last_activity"] = datetime.now()
                return session

            self.create_session(session_id, custom_config)
            return self.sessions.get(session_id)

    def update_heartbeat(self, session_id: str) -> bool:
        """更新会话的心跳时间"""
        with self._lock:
            if session_id in self.sessions:
                self.sessions[session_id]["last_heartbeat"] = datetime.now()
                logger.debug(f"Heartbeat updated for session: {session_id}")
                return True
            return False

    def _cleanup_taskweaver_session(self, session_data: Dict) -> None:
        """清理TaskWeaver会话资源"""
        try:
            taskweaver_session = session_data.get("taskweaver_session")
            taskweaver_app = session_data.get("taskweaver_app")
            
            if taskweaver_session:
                # 获取工作空间路径
                if hasattr(taskweaver_session, 'execution_cwd'):
                    workspace_path = taskweaver_session.execution_cwd
                    session_data["workspace_path"] = workspace_path
                
                # 停止TaskWeaver会话
                if hasattr(taskweaver_session, 'stop'):
                    taskweaver_session.stop()
                elif hasattr(taskweaver_session, 'close'):
                    taskweaver_session.close()
            
            # 清理TaskWeaver应用实例
            if taskweaver_app and taskweaver_app != self.base_taskweaver_app:
                try:
                    if hasattr(taskweaver_app, 'cleanup'):
                        taskweaver_app.cleanup()
                    elif hasattr(taskweaver_app, 'close'):
                        taskweaver_app.close()
                except Exception as app_cleanup_error:
                    logger.error(f"清理TaskWeaver应用失败: {app_cleanup_error}")
            
            # 清空引用
            session_data["taskweaver_session"] = None
            session_data["taskweaver_app"] = None
            
            logger.info("TaskWeaver会话和应用已清理")
        except Exception as e:
            logger.error(f"清理TaskWeaver会话失败: {e}")
    
    def _cleanup_workspace(self, workspace_path: str) -> None:
        """删除整个工作空间目录（含安全路径检查）"""
        try:
            if workspace_path and os.path.exists(workspace_path):
                safe_base = "/project/workspace/sessions" 
                abs_path = os.path.abspath(workspace_path)
                if not abs_path.startswith(os.path.normpath(safe_base)):
                    logger.warning(f"拒绝删除非工作空间路径: {workspace_path}")
                    return

                shutil.rmtree(abs_path)
                logger.info(f"已删除工作空间目录: {abs_path}")
            else:
                logger.debug(f"工作空间目录不存在或路径无效: {workspace_path}")
        except Exception as e:
            logger.error(f"清理工作空间失败 {workspace_path}: {e}")

    def delete_session(self, session_id: str, chat_service=None) -> bool:
        """删除指定的会话"""
        with self._lock:
            if session_id not in self.sessions:
                logger.warning(f"Session {session_id} not found for deletion")
                return False
    
            try:
                session_data = self.sessions[session_id]
                
                # 先取消活跃任务（如果提供了chat_service）
                if chat_service:
                    try:
                        import asyncio
                        loop = asyncio.get_event_loop()
                        if loop.is_running():
                            asyncio.create_task(chat_service.cancel_task(session_id))
                        else:
                            asyncio.run(chat_service.cancel_task(session_id))
                    except Exception as cancel_error:
                        logger.error(f"取消会话任务失败: {cancel_error}")
                
                # 清理TaskWeaver会话
                self._cleanup_taskweaver_session(session_data)
                
                # 清理工作空间
                workspace_path = session_data.get("workspace_path")
                if workspace_path:
                    self._cleanup_workspace(workspace_path)
                
                # 删除会话记录
                del self.sessions[session_id]
                if session_id in self.conversation_ids:
                    del self.conversation_ids[session_id]

                logger.info(f"Deleted session: {session_id}")
                return True
                
            except Exception as e:
                logger.error(f"Failed to delete session {session_id}: {e}")
                return False

    def list_sessions(self) -> List[str]:
        """列出所有活跃的会话ID"""
        with self._lock:
            return list(self.sessions.keys())

    def clear_all_sessions(self) -> None:
        """清理所有会话"""
        with self._lock:
            session_ids = list(self.sessions.keys())
            for session_id in session_ids:
                self.delete_session(session_id)
            
            logger.info(f"清理了 {len(session_ids)} 个会话")

    def get_conversation_id(self, session_id: str) -> str:
        """获取会话对应的对话ID"""
        with self._lock:
            return self.conversation_ids.get(session_id, "")

    def cleanup_inactive_sessions(self, timeout_minutes: int = 30) -> int:
        """清理基于活动和心跳的非活跃会话"""
        activity_cutoff = datetime.now() - timedelta(minutes=timeout_minutes)
        heartbeat_cutoff = datetime.now() - timedelta(minutes=2)  # 心跳超时设为2分钟
        inactive_sessions = []

        with self._lock:
            for sid, data in self.sessions.items():
                last_activity = data.get("last_activity")
                last_heartbeat = data.get("last_heartbeat")

                # 检查活动时间
                is_inactive = False
                if isinstance(last_activity, str):
                    try:
                        last_activity = datetime.fromisoformat(last_activity)
                    except ValueError:
                        last_activity = None
                
                if last_activity and last_activity < activity_cutoff:
                    is_inactive = True

                # 检查心跳时间 (如果会话是活跃的)
                is_heartbeat_lost = False
                if not is_inactive:
                    if isinstance(last_heartbeat, str):
                        try:
                            last_heartbeat = datetime.fromisoformat(last_heartbeat)
                        except ValueError:
                            last_heartbeat = None
                    
                    if last_heartbeat and last_heartbeat < heartbeat_cutoff:
                        is_heartbeat_lost = True

                if is_inactive or is_heartbeat_lost:
                    logger.info(
                        f"将清理会话 {sid}: "
                        f"inactive={is_inactive}, heartbeat_lost={is_heartbeat_lost}"
                    )
                    inactive_sessions.append(sid)

            for session_id in inactive_sessions:
                self.delete_session(session_id)

        logger.info(f"清理了 {len(inactive_sessions)} 个非活跃会话")
        return len(inactive_sessions)

    def get_session_message_history(self, session_id: str) -> List[Dict]:
        """获取会话消息历史"""
        with self._lock:
            return self.sessions.get(session_id)

    def get_session_stats(self) -> Dict:
        """获取会话统计信息"""
        with self._lock:
            total_sessions = len(self.sessions)
            active_sessions = sum(1 for s in self.sessions.values() if s.get("status") == "active")
            
            return {
                "total_sessions": total_sessions,
                "active_sessions": active_sessions,
                "cleanup_interval_minutes": self.cleanup_interval_minutes
            }
    
    def shutdown(self) -> None:
        """关闭会话管理器"""
        if self._cleanup_timer:
            self._cleanup_timer.cancel()
            self._cleanup_timer = None

        
        self.clear_all_sessions()
        logger.info("SessionManager已关闭")